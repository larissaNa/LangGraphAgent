# ğŸ¤– Agente de Pesquisa CientÃ­fica com LangGraph

Este projeto foi desenvolvido como parte do **Minicurso do ENUCOMPI 2025** e demonstra como criar um agente de pesquisa cientÃ­fica utilizando:

- ğŸ•¸ï¸ **LangGraph** (modelo de agentes baseados em estados)
- ğŸ§  **ChromaDB** (banco vetorial local)
- ğŸ¤– **Claude (Anthropic)** como modelo de linguagem
- ğŸŒ **Tavily AI** para busca na web
- ğŸ§± **LangChain** para orquestraÃ§Ã£o das ferramentas
- â±ï¸ **APScheduler** para agendamentos periÃ³dicos

## ğŸ“š Objetivo

Sistema Multiagente capaz de:

1. Realizar buscas em tempo real de artigos no **arXiv**.
2. Armazenar os artigos em um banco vetorial local (**ChromaDB**) com embeddings do HuggingFace.
3. Responder a perguntas gerais.
4. Executar tarefas agendadas como reindexaÃ§Ã£o ou atualizaÃ§Ãµes automÃ¡ticas.

## ğŸ§­ Fluxo do Sistema Multiagente

O diagrama abaixo mostra como os componentes interagem:

![Fluxograma do sistema](/images/fluxograma.png)


## ğŸš€ Como executar

1. Clone o repositÃ³rio:

```bash
git clone https://github.com/larissaNa/LangGraphAgent.git
```
2. Crie e ative um ambiente virtual:
```bash
cd <nome_pasta>
python -m venv venv
source venv/bin/activate   # Linux/macOS
.\venv\Scripts\activate    # Windows
```
3. Instale as dependÃªncias:
```bash
pip install -r requirements.txt
```
4. Execute o agente:
```bash
python main.py
```

## ğŸ“„ DocumentaÃ§Ã£o do CÃ³digo
#### ğŸ” 1. AutenticaÃ§Ã£o e variÃ¡veis de ambiente
```bash
def _set_env(var: str):
    if not os.environ.get(var):
        os.environ[var] = getpass.getpass(f"{var}: ")

_set_env("TAVILY_API_KEY")
_set_env("ANTHROPIC_API_KEY")
```
FunÃ§Ã£o: Garante que as variÃ¡veis de API (TAVILY_API_KEY, ANTHROPIC_API_KEY) estejam definidas no ambiente, solicitando via terminal se nÃ£o estiverem.

#### ğŸ§  2. InicializaÃ§Ã£o do modelo e ChromaDB
```bash
llm = init_chat_model("anthropic:claude-3-5-sonnet-latest")
embeddings = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
vectorstore = Chroma(
    collection_name="artigos_arxiv",
    embedding_function=embeddings,
    persist_directory="./chroma_db"
)
```
FunÃ§Ã£o:
- Inicializa o modelo Claude.
- Usa sentence-transformers para vetorizaÃ§Ã£o.
- Cria (ou carrega) uma coleÃ§Ã£o local no ChromaDB chamada artigos_arxiv.

#### ğŸ”§ 3. Ferramentas e agentes ReAct
```bash
tavily_tool = TavilySearch(max_results=2)
tools = [tavily_tool]
agent = create_react_agent(model=llm, tools=tools)

```
FunÃ§Ã£o: Registra a ferramenta TavilySearch como agente ReAct capaz de responder a buscas web.

#### ğŸ“š 4. Busca e ingestÃ£o no arXiv
```bash
class ArxivIngestInput(BaseModel):
    query: str
    max_results: int = 3

@tool("arxiv_search_and_ingest", args_schema=ArxivIngestInput)
def arxiv_search_and_ingest(query: str, max_results: int = 3) -> str:
    ...
```
FunÃ§Ã£o:

- Realiza uma busca na API do arXiv com o termo informado.
- Extrai tÃ­tulo, autores, resumo e link de cada artigo.
- Armazena resumos vetorizados no ChromaDB.
- Evita duplicatas via adicionados_arxiv_links.

#### â±ï¸ 5. Agendamento com APScheduler
```bash
scheduler = BackgroundScheduler()
scheduler.start()
active_jobs = {}
```
FunÃ§Ã£o: Inicia um agendador em segundo plano para execuÃ§Ãµes periÃ³dicas.

#### ğŸ“¥ Agendar pesquisa recorrente
```bash

@tool
def schedule_research(mensagem: str) -> str:
    ...
```
FunÃ§Ã£o:

- Reconhece comandos no formato:
    - "pesquise sobre [tema] durante [N] minutos a cada [M] segundos"
    - Executa arxiv_search_and_ingest() a cada intervalo, por tempo limitado.

#### âŒ Cancelar pesquisa agendada
```bash
@tool
def cancel_research(mensagem: str) -> str:
    ...

```
FunÃ§Ã£o: Cancela tarefas agendadas ativamente com base no nome do tema.

#### ğŸ¤– 6. CriaÃ§Ã£o dos Agentes
```bash
tavily_agent = create_react_agent(
    model=llm,
    tools=[tavily_tool],
    prompt= 'You perform web searches',
    name="tavily_agent"
)

arxiv_agent = create_react_agent(
    model=llm, tools=[arxiv_search_and_ingest], name="arxiv_agent",
    prompt="You search, ingest into ChromaDB and report arXiv papers."
)

sched_agent  = create_react_agent(
    llm,
    tools=[schedule_research, cancel_research],
    prompt="You schedule or cancel periodic arXiv searches.",
    name="scheduler_agent"
)

```
FunÃ§Ã£o: Cria trÃªs agentes:
-  Tavily: busca na web.
- arXiv: ingestÃ£o de artigos.
- Scheduler: agenda e cancela pesquisas.

#### ğŸ§‘â€âš–ï¸ 7. Supervisor
```bash
supervisor_graph = create_supervisor(
    model=llm,
    agents=[tavily_agent, arxiv_agent, sched_agent],
    prompt="VocÃª Ã© um supervisor que delega...",
    output_mode="full_history"
)
compiled_supervisor = supervisor_graph.compile()
```
FunÃ§Ã£o: Controla qual agente executa a tarefa, com base no conteÃºdo da mensagem. Gera histÃ³rico completo da conversa.

#### ğŸ”„ 8. Grafo com LangGraph
```bash
class StateSchema(TypedDict):
    messages: Annotated[list[BaseMessage], add_messages]

graph = StateGraph(StateSchema)
graph.add_node("supervisor", compiled_supervisor)
graph.add_edge(START, "supervisor")
compiled = graph.compile(checkpointer=MemorySaver())
```
FunÃ§Ã£o:

- Define o estado inicial com histÃ³rico de mensagens.
- Cria um grafo com o supervisor como nÃ³ principal.
- Usa MemorySaver para manter estado por sessÃ£o (thread).

#### ğŸ§ª 9. Loop interativo
```bash
def run(user_input: str):
    config = {"configurable": {"thread_id": "scheduler-thread"}}
    for chunk in compiled.stream({"messages": [...]}, config=config):
        ...

if __name__ == "__main__":
    ...
```
FunÃ§Ã£o:

- Permite interaÃ§Ã£o pelo terminal.
- LÃª comandos do usuÃ¡rio e executa o fluxo definido no grafo.
- Suporta mÃºltiplas interaÃ§Ãµes e threads com memÃ³ria.

## ğŸ§¾ Exemplos de comandos suportados pelo usuÃ¡rio
```bash
"pesquise sobre redes neurais durante 2 minutos a cada 30 segundos"
```
```bash
"cancelar busca sobre redes neurais"
```
```bash
"busque papers sobre transformers"
```
```bash
"Como esta o clima hoje em Piripiri PiauÃ­?"
```

## ğŸ§‘â€ğŸ« Sobre o minicurso
O minicurso "Criando agentes inteligentes com LangGraph" serÃ¡ apresentado no ENUCOMPI 2025 e abordarÃ¡ desde a construÃ§Ã£o de agentes baseados em memÃ³ria atÃ© sua integraÃ§Ã£o com busca web e bancos vetoriais para pesquisa cientÃ­fica automatizada.

